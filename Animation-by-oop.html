<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Animation</title>
    <style>
        canvas {
            display: block;
            margin: auto;
            background-color: black; /* Set the background to black */
        }
    </style>
</head>
<body>
    <canvas id="canvas1" width="800" height="400"></canvas>
    <script>
        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
     //   canvas.size = window.innerHeight;
        canvas.height = window.innerHeight;
    
        class Symbol {
            constructor(x, y, fontSize, canvasHeight , canvasWidth) {
                this.characters = 'アァカサタナハマヤラワガザダバパイキシチニヒミリギジヂビピヴックスヅプェエケテネヘメレゲゼデベペオォコントノホモヨョロラソンドポボヴッGHIJKLMNOPQRSTUVWXYZ';
                this.x = x;
                this.y = y;
                this.fontSize = fontSize;
                this.text = 'アァカサタナハマヤラワガザダバパイキシチニヒミリギジヂビピヴックスヅプェエケテネヘメレゲゼデベペオォコントノホモヨョロラソンドポボヴッGHIJKLMNOPQRSTUVWXYZ';
                this.canvasHeight = canvasHeight;
                this.canvasWidth = canvasWidth;
                console.log(this.characters);
            }

            draw(context) {
                this.text = this.characters.charAt(Math.floor(Math.random() * this.characters.length));
                context.fillStyle = 'rgba(0, 255, 0, 0.8)'; // Green color with transparency
                context.fillText(this.text, this.x * this.fontSize, this.y * this.fontSize);

                // Reset the position when the character reaches the bottom
                if (this.y * this.fontSize > this.canvasHeight  && Math.random() > 0.98) {
                    this.y = 0;
                } else {
                    this.y += 1; // Move the text down
                }
            }
        }

        class Effect {
            constructor(canvasWidth, canvasHeight) {
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                this.fontSize = 25; // Adjust the font size
                this.columns = this.canvasWidth / this.fontSize; // Number of columns
                this.symbols = [];
                this.#initialize();
               
            }

            #initialize() {
                for (let i = 0; i < this.columns; i++) {
                    this.symbols[i] = new Symbol(i, 0, this.fontSize, this.canvasHeight );
                }
            }
        }
    
        const effect = new Effect(canvas.width, canvas.height);
   let lastTime = 0;
   const fps = 30;
    const nextFrame = 1000/fps;
    let timmer = 0 ;

        function animate(timeStamp) {
            const deltaTime = timeStamp - lastTime;
            lastTime = timeStamp;
            if(timer > nextFrame){
            // Slightly darken the background for the trailing effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.textAlign = 'center'
            // Set the font properties
            ctx.font = effect.fontSize + 'px monospace';
            effect.symbols.forEach(symbol => symbol.draw(ctx));
            } else{
                timer += deltaTime;
            }
            // Continue the animation
            requestAnimationFrame(animate);
        }

        animate(); 
    </script>
</body>
</html>
